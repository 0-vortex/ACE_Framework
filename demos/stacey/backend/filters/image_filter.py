import asyncio
import re

from dotenv import load_dotenv

from llm.gpt import GPT
from util import get_environment_variable

PATTERN = r"IMAGE\[([^\]]+)]"  # Regular expression pattern to find all occurrences of IMAGE[<prompt>]


async def replace_image_prompt_with_image_url_formatted_as_markdown(image_generator_function, message):
    """
    Returns a new string where each IMAGE[<prompt>] is replaced with an image URL generated by GPT,
    formatted as markdown
    """

    matches = re.findall(PATTERN, message)  # Find all matches of the pattern in the message.

    # Create a list of coroutines to generate the images
    coroutines = [image_generator_function(match) for match in matches]

    # Await all coroutines to finish and get the results
    results = await asyncio.gather(*coroutines)

    for match, image_url in zip(matches, results):
        try:
            replacement = f"![{match}]({image_url})"
            message = message.replace(f"IMAGE[{match}]", replacement)
        except Exception as exc:
            print(f'Generated an exception: {exc}')
            # Handle exceptions as appropriate for your use case.

    return message  # Return the modified message with image URLs.


async def split_message_by_images(image_generator_function, message):
    """
    Splits the message by IMAGE[<prompt>], generates images using gpt,
    and returns a list containing texts and image URLs separated.
    For example 'here is a rabbit: IMAGE[rabbit] There you go!'
    will return ['here is a rabbit: ', <image_url>, ' There you go!']
    """

    segments = []  # List to store the segments of the message.
    last_end = 0  # The end of the last found IMAGE[<prompt>].

    # Create a list to hold the coroutines and their corresponding positions in the segments list
    coroutines = []
    positions = []

    for match in re.finditer(PATTERN, message):
        text_segment = message[last_end:match.start()].strip()  # Extract and strip the text before the IMAGE[<prompt>].

        if text_segment:  # Only append non-empty and non-whitespace text segments.
            segments.append(text_segment)

        image_prompt = match.group(1)  # Extract the prompt from the match.

        # Place a placeholder for the image URL in the segments list and store the coroutine and its position
        segments.append(None)
        coroutines.append(image_generator_function(image_prompt))
        positions.append(len(segments) - 1)

        last_end = match.end()  # Update the end of the last found IMAGE[<prompt>].

    final_text_segment = message[last_end:].strip()  # Extract and strip the remaining text after last IMAGE[<prompt>].

    if final_text_segment:  # Only append non-empty and non-whitespace final text segments.
        segments.append(final_text_segment)

    # Await all coroutines to finish and get the results
    results = await asyncio.gather(*coroutines)

    # Replace the placeholders with the actual image URLs once they are generated.
    for result, position in zip(results, positions):
        try:
            segments[position] = result  # Get the generated image URL and put it in the correct position.
        except Exception as exc:
            print(f'Generated an exception: {exc}')
            # Handle exceptions as appropriate for your use case.

    return segments  # Return the list containing text and image URLs.


if __name__ == '__main__':
    load_dotenv()
    test_message = "This is a test IMAGE[A painting of a cat sitting on a chair] and another IMAGE[A drawing of a sun]."
    gpt = GPT(get_environment_variable("OPENAI_API_KEY"))

    # Since the functions are now asynchronous, use asyncio.run to execute them
    print(asyncio.run(replace_image_prompt_with_image_url_formatted_as_markdown(gpt.create_image, test_message)))
