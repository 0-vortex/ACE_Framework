# tools/image_tool.py
import concurrent.futures
import os
import re

from dotenv import load_dotenv

from llm.gpt import GPT

PATTERN = r"IMAGE\[([^\]]+)]"  # Regular expression pattern to find all occurrences of IMAGE[<prompt>]


def replace_image_prompt_with_image_url_formatted_as_markdown(image_generator_function, message):
    """
    Returns a new string where each IMAGE[<prompt>] is replaced with an image URL generated by GPT, formatted as markdown
    """

    matches = re.findall(PATTERN, message)  # Find all matches of the pattern in the message.

    with concurrent.futures.ThreadPoolExecutor() as executor:
        # noinspection PyTypeChecker
        futures = [executor.submit(image_generator_function, match) for match in matches]  # Keep the order of futures the same as matches

    for match, future in zip(matches, futures):
        try:
            image_url = future.result()  # This will get the result in the order of submission
            replacement = f"![{match}]({image_url})"
            message = message.replace(f"IMAGE[{match}]", replacement)
        except Exception as exc:
            print(f'Generated an exception: {exc}')
            # Handle exceptions as appropriate for your use case.

    return message  # Return the modified message with image URLs.


def split_message_by_images(image_generator_function, message):
    """
    Splits the message by IMAGE[<prompt>], generates images using gpt, and returns a list containing texts and image URLs separated.
    For example 'here is a rabbit: IMAGE[rabbit] There you go!' will return ['here is a rabbit: ', <image_url>, ' There you go!']

    :param image_generator_function: A function that takes a prompt and returns an image URL.
    """

    segments = []  # List to store the segments of the message.
    last_end = 0  # The end of the last found IMAGE[<prompt>].

    # List to hold the futures and their corresponding positions in the segments list
    futures = []

    with concurrent.futures.ThreadPoolExecutor() as executor:
        for match in re.finditer(PATTERN, message):
            text_segment = message[last_end:match.start()].strip()  # Extract and strip the text before the IMAGE[<prompt>].

            if text_segment:  # Only append non-empty and non-whitespace text segments.
                segments.append(text_segment)

            image_prompt = match.group(1)  # Extract the prompt from the match.

            # Place a placeholder for the image URL in the segments list and store the future and its position
            segments.append(None)
            # noinspection PyTypeChecker
            futures.append((executor.submit(image_generator_function, image_prompt), len(segments) - 1))

            last_end = match.end()  # Update the end of the last found IMAGE[<prompt>].

        final_text_segment = message[last_end:].strip()  # Extract and strip the remaining text after the last IMAGE[<prompt>].

        if final_text_segment:  # Only append non-empty and non-whitespace final text segments.
            segments.append(final_text_segment)

        # Replace the placeholders with the actual image URLs once they are generated.
        for future, position in futures:
            try:
                segments[position] = future.result()  # Get the generated image URL and put it in the correct position.
            except Exception as exc:
                print(f'Generated an exception: {exc}')
                # Handle exceptions as appropriate for your use case.

    return segments  # Return the list containing text and image URLs.


if __name__ == '__main__':
    load_dotenv()
    test_message = "This is a test IMAGE[A painting of a cat sitting on a chair] and another IMAGE[A drawing of a sun]."
    gpt = GPT(os.getenv("OPENAI_API_KEY"))
    print(replace_image_prompt_with_image_url_formatted_as_markdown(gpt.create_image, test_message))
